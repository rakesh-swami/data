Spring Basics

1. @Component: A class/pojo that we want to be managed by Spring ioC - alternative - <bean id=“…” class=“”>
2. @Autowired: DI based on annotation.
3. @Qualifer: When have autowired an interface and there are multiple implementations - RedBox, BlueBox - @Autowirted @Quifier(“redbox”) Box 
4. @Value: to set value for a field using class-path properties files or hardcoding.
5. @Primary: When PTI, if you do not want to make use of @Qualifier, add @Primary to choose the default Auto Object.
6. @Scope: To set the scope of a @Component Class.
7. @PostConstruct
8. @PreDestroy
9. @ComponentScan("example.p_no_xml”): No need of XML file.
10. @Bean: Manage 3rd party classes using Spring.
11. @PropertySource: To set a class-path for a properties files: @PropertySource("classpath:application.properties") and use with @Value.
12. @Async and @EnableAsync: To run a method asynchronously. 
13. @Required: Deprecated 3.0
14. @Lazy: To load the bean lazily not when Spring containers starts.
15. @DependsOn: Used with @Bean when it depends on other beans, not adds tight coupling.
16. @ImportResource: To import xml-based beans to Spring using annotation: @ImportResource("classpath:legacy-config.xml")
17. @Import: can be used to import classes as bean: @Import({DatabaseConfig.class, MessagingConfig.class})
18. @Lookup: When you inject and prototype scope Class to a Singleton one - results not write - use lookup with a method.
19. @Profile("development”): Based on the profile its activated: spring.profiles.active=development


I am a result-oriented Software Developer with 11.9 years of experience in cloud-native application development. Having a strong understanding of Agile Software Development Methodologies. 



Spring REST API Revision 
 List of annotations we have seen so far 
1. @RestContoller - @Controller + @ResponseBody 
2. @GetMapping 
3. @PostMapping 
4. @PathVariable - /user/{id} 
5. @RequestParam – user?id= 
6. @RequestBody – get the post request as a JSON. 
7. @ResponseStatus – send a HTTP response back. 
8. @PutMapping 
9. @DeleteMapping 


				— Spring MVC Annotations——

1. @Controller - special type of @Component ( C of MVC)
2. @RequestMapping = can use any kind of method as fields - example - (value = "/ex/foos", method = POST)
3. @RequestParams - ?name=
4. ModelMap to send data to the View
5. @ModelAttribute
6. @SessionAttribute
7. @PathVariable




How MVC Works







￼



1. @Service - special type of @Component
2. @Repository - JPA  - special type of @Component
3. @ResponseBody - used with @RequestMapping in method argument to tell the object will be returned as response. with RestController.
4. @SessionAttributes - to add a parameter to session scope.




1. POJO - Plain Old Java Object
2. IoC - Creating objects in an expensive task, and gets tightly coupled using new keyword, instead let Spring Container create and manage it.
3. DI - Instead of we as a developer creating an object inside a class - let it be injected using - Constructor, Setter or Field or Annotation.
4. Spring Bean - A class managed my IoC.
5. Scope of a Bean 
    1. Singleton (Default)
    2. Prototype
    3. Application
    4. Session
    5. GlobalSession
6. Life Cycle Methods - init-method= destroy-method


Example 1: without IOC:

public interface Coach {
    String getDailyWorkout();
}

public class BaseBallCoach implements Coach {
    @Override
    public String getDailyWorkout() {
        return "Spend 30 mins walking everyday!";
    }
}

public class TrackCoach implements Coach {
    @Override
    public String getDailyWorkout() {
        return "Run at least 10 mins...";
    }
}


public class MyApp {

    public static void main(String[] args) {

	Coach baseBallCoach = new BaseBallCoach();
	System.out.println(baseBallCoach.getDailyWorkout());

	Coach trackCoach = new TrackCoach();
	System.out.println(trackCoach.getDailyWorkout());


    }
}

——
Example 2: Using IoC: No new keyword - object managed by Container.


ClassPathXmlApplicationContext cpac = new ClassPathXmlApplicationContext("applicationContext2.xml");

Coach baseBallCoach = cpac.getBean("baseBallCoach", Coach.class);
System.out.println(baseBallCoach.getDailyWorkout());

Coach trackCoach = cpac.getBean("trackCoach", Coach.class);
System.out.println(trackCoach.getDailyWorkout());


applicationContext.xml file
<bean id="baseBallCoach" class="example.b_no_ioc.BaseBallCoach"/>
<bean id="trackCoach" class="example.b_no_ioc.TrackCoach" />


———
Example 3: Constructor based DI

public class TrackCoach {


private KitService kitService;

public TrackCoach(KitService kitService) {
  this.kitService = kitService;

}


<bean id=“kitService" class="example.KitService"/>
<bean id="trackCoach" class="example.e.TrackCoach">
    <constructor-arg ref="kitService"/>
</bean>


———
Example 4: Setter based DI

<bean id=“kitService" class="example.KitService"/>
<bean id="trackCoach" class="example.e.TrackCoach">
    <property  name="kitService" ref=“kitService” />
</bean>

———
Example 5: Field based DI (Setter and Constructor)
<bean id="trackCoach" class="example.e.TrackCoach">
    <property  name=“email” value=“coach@google.com” />
</bean>

<bean id="trackCoach" class="example.e.TrackCoach">
    <constructor-arg  name=“email” value=“coach@google.com” />
</bean>

————
Example 6: Property file based DI

<context:property-placeholder location="classpath:config.properties" />
<bean id="trackCoach" class="example.g_property_file_based_injection.TrackCoach">
   <constructor-arg name="email" value="${coach.email}"/>
</bean>

Config.properties
coach.email="abc@xyz.com"

———
Example 7: Scopes - Singleton, Prototype, Session, Application, Global Session

Prototype: <bean id="fieldCoach" class="example.h_scope_prototype.FieldCoach" scope="prototype" />

———
Example 8: Lifecycle methods

<bean id="trackCoach" class="example.i_lifecycle_methods_init_destroy.TrackCoach"
   init-method="tcoachInit" destroy-method="tcoachDestroy"/>

——
Example 9: Component Scan (instead of XML Beans)

<context:component-scan base-package="example.j_annotation_component_scan"/>

Here - Component = <bean> managed by IOC

@Component("fieldCoach") //note - names are not required
@Component("trackCoach")

——
Example 10: @Autowired

@Component
public class BaseBallCoach implements Coach {

    @Autowired //Field based
    FortuneService fortuneService;

    public String getDailyWorkout() {
        return "Spend 30 mins walking everyday!";
    }

    @Override
    public String getDailyFortune() {
        return fortuneService.getFortune();
    }

    @Autowired //Constructor based - preferred.
    public FortuneService getFortuneService() {
        return fortuneService;
    }

    @Autowired //Setter based
    public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
    }
}


——
Example 11: @Qualifier annotation

public interface Box {}

@Component(“redBox”)
public class RedBox implements Box {}

@Component(“blueBox”)
public class BlueBox implements Box {}

@Autowired
@Qualifer
private Box box;



—— 
Example 12: @Value

@Value("${coach.email}")
private String email;

——
Example 13: @Scope

@Component
@Scope("prototype")
public class FieldCoach implements Coach {


——
Example 14: Life cycle annotations:

@PostConstruct
public void fcoachInit() {
    System.out.println("Field coach init...");
}

@PreDestroy
public void fcoachDestroy() {
    System.out.println("Field coach destroy...");
}

———
Example 15: Without XML

- Create a SpringConfig class.

@Component
@ComponentScan("example.p_no_xml")
public class SpringConfig {
}

———
Example 16: @Bean

- When you have classes from 3rd party not managed by Spring.

@Bean
public FortuneService happyFortuneService() {
    return new HappyFortuneService();
}


															—— Spring Boot ——


Starter projects! start.spring.io

JPA VS Hibernate 

JPA - org.persistence.jakarta packages (Specification)
Hibernate - org.hibernate packages (Implementation such as toplink)

Why not use Hibernate - cos we get locked into one type!


								
1. JDBC
2. Spring Data JDBC - JDBCTemplate
3. Spring JPA - use EntityManager
4. Spring Data JPA  - not even EntityManager is required!

- Spring Data JDBC
- Spring Data JPA
- Spring Web
- MySQL Driver

1. Spring Data JDBC

Step 1: Just autowire JdbcTemplate

@Autowire
private JdbcTemplate  jdbcTemplate;

Step 2: Use it.

List<Message> messages = jdbcTemplate.query("Select * from message", new BeanPropertyRowMapper<>(Message.class));


—————— 
2. Spring JPA

Step 1: Create your entity 

@Entity
public class Employee {

    @Id
    private int empId;

    @Column
    private String empName;


Step 2: Create @Repository

@Repository
public class EmployeeRepository  {

    @PersistenceContext //or @Autowired
    private EntityManager entityManager;

    public void insert(Employee employee) {
        entityManager.merge(employee);
    }
}


Step 3: Use.

@Autowire
pivate EmployeeRepository repository;

repository.insert(emp1);



—
4. Spring Data JPA

@Entity
public class Employee {

    @Id
    private int empId;

    @Column
    private String empName;


public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    //<Entity, ID type>
}

That’s all!


				— Spring MVC Example ——

Annotations

1. @Controller - special type of @Component
2. @Service - special type of @Component
3. @Repository - JPA -  - special type of @Component
4. @RequestMapping = can use any kind of method as fields - example - (value = "/ex/foos", method = POST)
5. @ResponseBody - used with @RequestMapping in method argument to tell the object will be returned as response. with RestController.
6. @RequestParams - ?name=
7. @SessionAttributes - to add a parameter to session scope.


@Controller
public class Controller {

    @ResponseBody
    @RequestMapping("message")
    public String sayMessage() {
        return "hello world!";
    }
}

// Lets create JSP Page

Step 1: Create folders - META-INF/resources/WEB-INF/jsp under src/main/resources
Step 2: Add this to application.properties file.

spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

index.jsp

<h2>hello world!</h2>

Note: remove ResponseBody

@Controller
public class Controller {


    @RequestMapping("message")
    public String sayMessage() {
        return “index!”;
    }
}



— @RequestParam and ModelMap


@RequestMapping("login")
public String sayMessage(@RequestParam String name, ModelMap modelMap) {
    modelMap.put("name",name);
    return "login";
}

?name=Rakesh





— Spring REST API


@RestController
@RequestMapping or @GetMapping or so on

Pass as Object and it will be converted to JSON - JacksonHTPPJSON

Path Parameter -  /user/{id}/{path} 

@PathVariable



Spring Boot


1. What is Spring boot

- It is a Java RAD framework based on the Spring framework
- Takes advantage of the IoC and DI
- Very less configuration thus reducing the boilerplate code.
- Embedded tomcat - so testing and deployment becomes easy.
- Create standalone application

- Starter dependencies
- Spring initializer - tool start.spring.io
- Support for lot of technologies such as,
	1. JPA
	2. Rest
	3. Data MongoDB
	4. Data Elasticsearch
	5. Data Solr
	6. Data JDBC
	7. Web
	8. Thymeleaf
	9. Mustache
	10. Security
	11. OAuth2 Client
	12. Test
	13. AMQP
	14. Kafka
	15. Cloud
	16. Batch
	18. Data Rest
	19. Cache
	20. Mail
	21. Actuator
